const eccrypto = require('eccrypto');
const { webcrypto } = require('crypto');
const { Buffer } = require('buffer');
const { publicToAddress } = require('@ethereumjs/util');

module.exports = {
  createWallet: () => {
    const privateKeyBuf = eccrypto.generatePrivate();
    return { privateKey: privateKeyBuf.toString('hex'), publicKey: eccrypto.getPublic(privateKeyBuf).toString('hex') };
  },
  createPublicKeyFromPrivateKeyWallet: (walletPrivateKey) => {
    return eccrypto.getPublic(Buffer.from(walletPrivateKey, 'hex')).toString('hex');
  },
  convertWalletPublicKeyToAddress: async (publicKey) => {
    try {
      const postAddress = publicToAddress(
        Buffer.from(publicKey, 'hex'),
        true,
      ).toString('hex');

      return '0x' + postAddress.toLowerCase();
    } catch (e) {
      throw new Error(`Invalid public key share ${e}`);
    }
  },
  decryptGetKeyAes: async (encryptedKey, walletPrivateKey) => {
    try {
      const [ciphertext, ephemPublicKey, iv, mac] = encryptedKey.split('@@');
      const key = await eccrypto.decrypt(
        Buffer.from(walletPrivateKey, 'hex'),
        {
          ciphertext: Buffer.from(ciphertext, 'hex'),
          ephemPublicKey: Buffer.from(ephemPublicKey, 'hex'),
          iv: Buffer.from(iv, 'hex'),
          mac: Buffer.from(mac, 'hex'),
        },
      );
      const masterKey = await webcrypto.subtle.importKey(
        'raw',
        Buffer.from(JSON.parse(key).key, 'hex'),
        'AES-GCM',
        true,
        ['encrypt', 'decrypt'],
      );
      return {
        key: masterKey,
        iv: JSON.parse(key).iv,
      };
    } catch (e) {
      throw new Error(`fail to decrypt get  key encrypt file ${e}`);
    }
  },
  encryptKeyAesByWalletPublicKey: async (key, iv, walletPublicKey) => {
    try {
      const exported = await webcrypto.subtle.exportKey('raw', key);
      const data = {
        iv: typeof iv === 'string' ? iv : Buffer.from(iv).toString('hex'),
        key: Buffer.from(exported).toString('hex'),
      };

      const selfEncrypted = await eccrypto.encrypt(
        Buffer.from(walletPublicKey, 'hex'),
        Buffer.from(JSON.stringify(data), 'utf-8'),
      );

      return `${selfEncrypted.ciphertext.toString('hex')}@@${selfEncrypted.ephemPublicKey.toString(
        'hex',
      )}@@${selfEncrypted.iv.toString('hex')}@@${selfEncrypted.mac.toString('hex')}`;
    } catch (error) {
      throw new Error(`error encrypt key encryption by wallet public key ${error}`);
    }
  },
};
