const eccrypto = require('eccrypto');
const { webcrypto } = require('crypto');
const { Buffer } = require('buffer');
const fs = require('fs');
const path = require('path');
const mime = require('mime-types');

const { announceList, ipfsGateway } = require('./src/config');
const { signLogin, requestSignUrl, requestSignUrlList, convertSignToStringHex } = require('./src/sign');
const { uploadFile } = require('./src/uploadFile');
const { uploadFileTorrent } = require('./src/uploadFileTorrent');
const { createTorrentFile } = require('./src/seed');
const { uploadKeyEncrypt } = require('./src/uploadKeyEncrypt');
const {
  decryptGetKeyAes,
  convertWalletPublicKeyToAddress,
  encryptKeyAesByWalletPublicKey,
  createWallet,
  createPublicKeyFromPrivateKeyWallet,
} = require('./src/ecdsa');
const {
  createKeyAes,
  convertFileEncryptionKeyAesToObject,
  createIV,
  encryptFileWithKeyAes,
  decryptDataByKeyAes,
} = require('./src/aes');

const {
  callCreateAccount,
} = require('./src/user');

const { hashIpfs } = require('./src/ipfs');
const {
  callGetObjectLists,
  callGetObjectDetail,
  callDeleteFile,
  callGetSharedFiles,
  callCreateFolder,
} = require('./src/file');

const { shareTo } = require('./src/shareTo');
const { callCreateProject, callGetPersonalProject } = require('./src/project');

class Eueno {
  constructor(opts = {}) {
    if (opts.endpoint === undefined) {
      throw new Error('end point invalid');
    }
    this.endpoint = opts.endpoint;

    if (opts.ipfsGateway !== undefined) {
      this.ipfsGateway = opts.ipfsGateway + '/ipfs';
    } else {
      this.ipfsGateway = ipfsGateway + '/ipfs';
    }
  }

  // SERVICE EUENO
  async getObjectDetail(opts) {
    if (opts.fileId === undefined) {
      throw new Error('fileId invalid');
    }
    opts.endpoint = this.endpoint;
    if (opts.projectKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }
    if (!opts.signData) {
      opts.signData = await signLogin(opts.projectKey);
    }
    return callGetObjectDetail(opts);
  }

  async getObjectLists(opts) {
    if (opts.path !== undefined) {
      opts.params = `folderPath=${opts.path}`;
    } else {
      opts.params = '';
    }

    if (opts.projectKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }
    if (opts.projectId === undefined) {
      throw new Error('projectId invalid');
    }

    if (!opts.signData) {
      opts.signData = await signLogin(opts.projectKey);
    }
    opts.endpoint = this.endpoint;
    return callGetObjectLists(opts);
  }

  async deleteObject(opts) {
    if (opts.fileId === undefined) {
      throw new Error('fileId invalid');
    }
    opts.endpoint = this.endpoint;
    if (opts.projectKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }
    if (!opts.signData) {
      opts.signData = await signLogin(opts.projectKey);
    }
    return callDeleteFile(opts);
  }

  async shareTo(opts) {
    if (opts.fileId === undefined) {
      throw new Error('fileId invalid');
    }
    if (opts.projectId === undefined) {
      throw new Error('projectId invalid');
    }
    opts.endpoint = this.endpoint;
    if (opts.projectKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }
    const file = await this.getObjectDetail(opts);
    if (file.code === 404) {
      return file;
    }

    if (file.data.method === 'ENCRYPT') {
      if (opts.walletPrivateKey === undefined) {
        throw new Error('walletPrivateKey invalid');
      }
      if (opts.walletPublicKeyShare === undefined) {
        throw new Error('walletPublicKeyShare invalid');
      }

      if (file.data.encryptKey === undefined) {
        return {
          code: 404,
          msg: 'key encrypt file not found',
          file: file.data,
        };
      }
      const fileEncryptionKey = await decryptGetKeyAes(file.data.encryptKey, opts.walletPrivateKey);
      opts.addressShare = await convertWalletPublicKeyToAddress(opts.walletPublicKeyShare);
      opts.encryptedKeyShare = await encryptKeyAesByWalletPublicKey(fileEncryptionKey.key, fileEncryptionKey.iv, opts.walletPublicKeyShare);
    }

    return shareTo(opts);
  }

  async upload(input, opts, metadata) {
    if (metadata.contentLength === undefined) {
      throw new Error('contentLength invalid');
    }
    if (metadata.contentType === undefined) {
      throw new Error('contentType invalid');
    }
    if (metadata.filename === undefined) {
      throw new Error('filename invalid');
    }
    if (metadata.method !== 'ENCRYPT' && metadata.method !== 'UNENCRYPTED') {
      throw new Error('method invalid');
    }

    if (metadata.method === 'ENCRYPT') {
      if (opts.key.walletPublicKey === undefined) {
        throw new Error('walletPublicKey invalid');
      }
      if (opts.key.fileEncryptionKey === undefined) {
        opts.key.fileEncryptionKey = await createKeyAes();
      }
    }

    if (opts.projectKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }

    opts.endpoint = this.endpoint;
    opts.ipfsGateway = this.ipfsGateway;

    return _prepareFile(input, opts, metadata);
  }

  async readFolder(folderPath) {
    const filesInFolder = fs.readdirSync(folderPath);
    const folderName = path.basename(folderPath);
    return _readFolder(filesInFolder, folderName);
  }

  async uploadFolder(input, opts, metadata) {
    if (opts.projectKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }
    if (metadata.projectId === undefined) {
      throw new Error('Project ID invalid');
    }
    for (const fileMetadata of metadata.pathLists) {
      if (fileMetadata.filename === undefined) {
        throw new Error('filename invalid');
      }
      if (fileMetadata.contentType === undefined) {
        throw new Error('contentType invalid');
      }
      if (fileMetadata.contentLength === undefined) {
        throw new Error('contentLength invalid');
      }
      if (fileMetadata.method !== 'ENCRYPT' && fileMetadata.method !== 'UNENCRYPTED') {
        throw new Error('method invalid');
      }
      if (fileMetadata.method === 'ENCRYPT') {
        if (opts.key.walletPublicKey === undefined) {
          throw new Error('walletPublicKey invalid');
        }
        if (opts.key.fileEncryptionKey === undefined) {
          opts.key.fileEncryptionKey = await createKeyAes();
        }
      }
    }
    if (!opts.signData) {
      opts.signData = await signLogin(opts.projectKey);
    }
    opts.endpoint = this.endpoint;
    opts.ipfsGateway = this.ipfsGateway;
    return _prepareFolder(input, opts, metadata);
  }

  async createFolder(opts) {
    if (opts.projectKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }

    if (opts.path === undefined) {
      throw new Error('path invalid');
    }

    if (!opts.signData) {
      opts.signData = await signLogin(opts.projectKey);
    }
    opts.endpoint = this.endpoint;

    return callCreateFolder(opts);
  }

  async createAccount(opts) {
    if (opts.projectKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }

    if (opts.account === undefined) {
      throw new Error('account invalid');
    }

    if (!opts.signData) {
      opts.signData = await signLogin(opts.projectKey);
    }
    opts.endpoint = this.endpoint;

    return callCreateAccount(opts);
  }

  //KEY
  async createKeyAes() {
    return createKeyAes();
  }

  async createWallet() {
    return createWallet();
  }

  async createPublicKeyFromPrivateKeyWallet(walletPrivateKey) {
    return createPublicKeyFromPrivateKeyWallet(walletPrivateKey);
  }

  async decryptDataByKeyAes(input, fileEncryptionKey, iv) {
    if (typeof input === 'string') {
      throw new Error('input only buffer file');
    }
    if (typeof fileEncryptionKey !== 'string') {
      throw new Error('fileEncryptionKey must string');
    }
    fileEncryptionKey = await convertFileEncryptionKeyAesToObject(fileEncryptionKey);

    return decryptDataByKeyAes(input, fileEncryptionKey, iv);
  }

  async decryptGetKeyAesWithPriKeyWallet(input, walletPrivateKey) {
    if (typeof walletPrivateKey !== 'string') {
      throw new Error('walletPrivateKey must string');
    }
    const decrypt = await decryptGetKeyAes(input, walletPrivateKey);
    return {
      fileEncryptionKey: (await webcrypto.subtle.exportKey('jwk', decrypt.key)).k,
      iv: decrypt.iv,
    };
  }

  async getSharedFiles(opts) {
    if (opts.walletPrivateKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }
    if (opts.projectId === undefined) {
      throw new Error('Project ID invalid');
    }
    if (!opts.signData) {
      if (typeof opts.walletPrivateKey !== 'string') {
        throw new Error('walletPrivateKey must string');
      }
      opts.signData = await signLogin(opts.walletPrivateKey);
    }
    if (opts.page === undefined) {
      opts.page = 1;
    }
    if (opts.limit === undefined) {
      opts.limit = 10;
    }
    opts.endpoint = this.endpoint;
    return callGetSharedFiles(opts);
  }

  async createProject(opts) {
    if (opts.walletPrivateKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }
    if (opts.projectName === undefined) {
      throw new Error('projectName invalid');
    }
    if (typeof opts.projectName !== 'string') {
      throw new Error('projectName must string');
    }
    if (!opts.signData) {
      if (typeof opts.walletPrivateKey !== 'string') {
        throw new Error('walletPrivateKey must string');
      }
      opts.signData = await signLogin(opts.walletPrivateKey);
    }
    opts.endpoint = this.endpoint;
    return callCreateProject(opts);
  }

  async getPersonalProject(opts) {
    if (opts.walletPrivateKey === undefined && opts.signData === undefined) {
      throw new Error('Authentication invalid');
    }
    if (opts.signData && typeof opts.signData.signature === 'object') {
      opts.signData.signature = convertSignToStringHex(opts.signData.signature);
    }
    if (opts.page === undefined) {
      opts.page = 1;
    }
    if (opts.limit === undefined) {
      opts.limit = 100;
    }
    if (opts.sortBy === undefined) {
      opts.sortBy = 'id:asc';
    }
    if (!opts.signData) {
      if (typeof opts.walletPrivateKey !== 'string') {
        throw new Error('walletPrivateKey must string');
      }
      opts.signData = await signLogin(opts.walletPrivateKey);
    }
    opts.endpoint = this.endpoint;
    return callGetPersonalProject(opts);
  }
}

const _readFolder = (filesInFolder, folderName) => {
  let filesInBuffer = [];
  let filesMetadata = [];
  for (const filename of filesInFolder) {
    const path = `./${folderName}/`;
    const fileInfo = fs.lstatSync(`${path}${filename}`);

    if (!fileInfo.isDirectory()) {
      const fileData = fs.readFileSync(`${path}${filename}`);
      fileData.name = filename;
      filesInBuffer.push(fileData);
      filesMetadata.push({
        path: `${folderName}`,
        filename,
        contentLength: fileData.length,
        contentType: mime.lookup(filename),
        method: 'UNENCRYPTED',
      });
    } else {
      const subFolder = fs.readdirSync(`${folderName}/${filename}`);
      const subFiles = _readFolder(subFolder, `${folderName}/${filename}`);
      filesInBuffer = [...filesInBuffer, ...subFiles.input];
      filesMetadata = [...filesMetadata, ...subFiles.pathLists];
    }
  }
  return { input: filesInBuffer, pathLists: filesMetadata };
};

const _prepareFile = async (input, opts, metadata) => {
  if (typeof input === 'string') {
    throw new Error('input only buffer file');
  }

  if (metadata.method === 'ENCRYPT') {
    const [keyConvert, iv] = await Promise.all([
      await convertFileEncryptionKeyAesToObject(opts.key.fileEncryptionKey),
      await createIV()]);

    const [encryptedFileData, encryptedKey] = await Promise.all([
      await encryptFileWithKeyAes(input, keyConvert, iv),
      await encryptKeyAesByWalletPublicKey(keyConvert, iv, opts.key.walletPublicKey)]);

    input = encryptedFileData;
    opts.key.encryptedKey = encryptedKey;
    opts.key.iv = Buffer.from(iv).toString('hex');
  }
  return _upload(input, opts, metadata);
};

const _prepareFolder = async (input, opts, metadata) => {
  const limitNumberOfFilesEachBatch = 100;
  if (Object.values(input).every((el) => typeof el === 'string')) {
    throw new Error('input only buffer file');
  }

  const filteredInput = input.filter((el) => el.name !== '.DS_Store');
  metadata.pathLists = metadata.pathLists.filter((el) => el.filename !== '.DS_Store');
  let iv;
  let keyConvert;
  for (let i = 0; i < filteredInput.length; i++) {
    if (metadata.pathLists[i].method === 'ENCRYPT') {
      if (!opts.key._k) {
        [keyConvert, iv] = await Promise.all([
          await convertFileEncryptionKeyAesToObject(opts.key.fileEncryptionKey),
          await createIV()]);
        opts.key.iv = Buffer.from(iv).toString('hex');
        opts.key.encryptedKey = await encryptKeyAesByWalletPublicKey(keyConvert, iv, opts.key.walletPublicKey);
      }
      const encryptedFileData = await encryptFileWithKeyAes(filteredInput[i], keyConvert, iv);
      const fileName = filteredInput[i].name;
      filteredInput[i] = encryptedFileData;
      filteredInput[i].name = fileName;
    }
  }
  if (filteredInput.length <= limitNumberOfFilesEachBatch) {
    // eslint-disable-next-line no-use-before-define
    return _uploadFolder(filteredInput, opts, metadata);
  }
  // process upload by batch
  let result = [];
  let i = 0;
  while (true) {
    const subInput = filteredInput.slice(i, i + limitNumberOfFilesEachBatch);
    const subMetadata = {
      projectId: metadata.projectId,
      pathLists: metadata.pathLists.slice(i, i + limitNumberOfFilesEachBatch),
    };
    const subResult = await _uploadFolder(subInput, opts, subMetadata);
    result = [...result, ...subResult];
    if (i + limitNumberOfFilesEachBatch >= filteredInput.length) break;
    i += limitNumberOfFilesEachBatch;
  }
  return result;
};

const _upload = async (input, opts, metadata) => {
  if (!opts.signData) {
    opts.signData = await signLogin(opts.projectKey);
  }
  const cidFile = await hashIpfs(input);
  opts = await _getOpts(opts);
  opts.urlList = [`${opts.ipfsGateway}/${cidFile}`];
  const torrent = await createTorrentFile(input, opts);
  const cidTorrent = await hashIpfs(torrent);
  metadata.cidFile = cidFile;
  metadata.cidTorrentFile = cidTorrent;
  const signUrl = await requestSignUrl(opts, metadata);
  if (signUrl.status !== 200) {
    throw new Error(`error request sign ${JSON.stringify(signUrl)}`);
  } else {
    opts.urlUploadFile = signUrl.data.uploadFileUrl;
    opts.urlUploadTorrent = signUrl.data.uploadTorrentUrl;
    metadata.filename = signUrl.data.filename;
    metadata.filePath = signUrl.data.filePath;
  }

  const [a, b] = await Promise.all([uploadFile(input, opts, metadata), uploadFileTorrent(torrent, opts, metadata)]);
  if (typeof a !== 'object') {
    throw new Error(JSON.stringify(a));
  } else if (typeof b !== 'object') {
    throw new Error(JSON.stringify(b));
  }

  const result = {
    file: `${opts.ipfsGateway}/${cidFile}`,
    torrent: `${opts.ipfsGateway}/${cidTorrent}`,
    filename: metadata.filename,
    filePath: metadata.filePath,
  };

  if (metadata.method === 'ENCRYPT') {
    result.fileEncryptionKey = opts.key.fileEncryptionKey;
    result.encryptedKey = opts.key.encryptedKey;
    result.encryptedDataFile = input;
    result.iv = opts.key.iv;
    setTimeout(async () => {
      const c = await uploadKeyEncrypt(opts.key.encryptedKey, opts, metadata);
      if (c.msg !== 'success') {
        throw new Error(JSON.stringify(c));
      }
    }, 2000);
  }
  return result;
};

async function _uploadFolder(input, opts, metadata) {
  const metadataFileList = [];
  const optsList = [];
  const torrentList = [];
  let encryption = false;
  for (let i = 0; i < input.length; i++) {
    if (metadata.pathLists[i].method === 'ENCRYPT') encryption = true;
    let optsTemp = { ...opts };
    const cidFile = await hashIpfs(input[i]);
    optsTemp = _getOptsCreateTorrent(optsTemp);
    optsTemp.urlList = [`${opts.ipfsGateway}/${cidFile}`];
    const torrent = await createTorrentFile(input[i], optsTemp);
    torrentList.push(torrent);
    const cidTorrent = await hashIpfs(torrent);
    metadataFileList.push({
      ...metadata.pathLists[i],
      cidFile,
      cidTorrentFile: cidTorrent,
    });
    optsList.push(optsTemp);
  }
  metadata.pathLists = metadataFileList;
  let signUrlList = await requestSignUrlList(opts, metadata);
  if (signUrlList.status !== 200) {
    throw new Error(`error request sign ${JSON.stringify(signUrlList)}`);
  }
  signUrlList = signUrlList.data;
  optsList.forEach((_, idx, arr) => {
    arr[idx].urlUploadFile = signUrlList[idx].uploadFileUrl;
    arr[idx].urlUploadTorrent = signUrlList[idx].uploadTorrentUrl;
    metadata.pathLists[idx].filename = signUrlList[idx].filename;
    metadata.pathLists[idx].filePath = signUrlList[idx].filePath;
  });
  let result = await Promise.all(
    input.map(async (el, idx) => {
      const [a, b] = await Promise.all([
        uploadFile(el, optsList[idx], metadata.pathLists[idx]),
        uploadFileTorrent(torrentList[idx], optsList[idx], metadata.pathLists[idx]),
      ]);
      if (typeof a !== 'object') {
        throw new Error(JSON.stringify(a));
      } else if (typeof b !== 'object') {
        throw new Error(JSON.stringify(b));
      }
      const fileResult = {
        file: `${opts.ipfsGateway}/${metadata.pathLists[idx].cidFile}`,
        torrent: `${opts.ipfsGateway}/${metadata.pathLists[idx].cidTorrentFile}`,
        filename: el.name,
        filePath: metadataFileList[idx].filePath,
      };
      return fileResult;
    }),
  );
  if (encryption) {
    await new Promise((resolve) => setTimeout(resolve, 5000));
    for (let i = 0; i < input.length; i++) {
      if (metadata.pathLists[i].method === 'ENCRYPT') {
        result[i].fileEncryptionKey = optsList[i].key.fileEncryptionKey;
        result[i].encryptedKey = optsList[i].key.encryptedKey;
        result[i].encryptedDataFile = input[i];
        result[i].iv = opts.key.iv;
        metadata.pathLists[i].projectId = metadata.projectId;
        const uploadKey = await uploadKeyEncrypt(result[i].encryptedKey, optsList[i], metadata.pathLists[i]);
        if (uploadKey.msg !== 'success') {
          throw new Error(JSON.stringify(uploadKey));
        }
      }
    }
  }
  return result;
}

function _getOpts(opts) {
  if (opts.announce !== undefined) {
    opts.announce = opts.announce.concat(announceList);
  } else {
    opts.announce = announceList;
  }
  opts.private = true;
  return opts;
}

function _getOptsCreateTorrent(opts) {
  if (opts.announceList !== undefined) {
    opts.announceList = opts.announceList.concat(announceList);
  } else {
    opts.announceList = announceList;
  }
  opts.private = true;
  return opts;
}

module.exports = Eueno;
